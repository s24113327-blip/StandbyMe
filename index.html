<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STAND-BY-ME 3D | Neon Night Market</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --neon-green: #39ff14;
            --neon-pink: #ff007f;
            --neon-blue: #00f2ff;
            --wood: #3e2723;
        }

        body {
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
            color: white; margin: 0; display: flex; justify-content: center; align-items: center;
            min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden;
        }

        .night-market-scene { display: flex; flex-direction: column; align-items: center; gap: 20px; }

        .arcade-title {
            margin: 0; font-size: 3.5rem; font-weight: 900; letter-spacing: 8px; color: #fff;
            text-shadow: 0 0 15px #fff, 0 0 25px var(--neon-pink), 0 0 50px var(--neon-pink);
            animation: flicker 3s infinite alternate;
        }

        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { opacity: 1; }
            20%, 22%, 24%, 55% { opacity: 0.85; }
        }

        .arcade-cabinet {
            background: #263238; padding: 12px; border: 6px solid #455a64; border-radius: 12px;
            box-shadow: 0 0 60px rgba(0,0,0,0.9);
        }

        .main-layout { display: flex; gap: 15px; background: #000; padding: 10px; border-radius: 4px; }

        .canvas-area { 
            position: relative; width: 800px; height: 450px; 
            border: 3px solid #111; overflow: hidden;
        }

        #gameCanvas { background: #000; display: block; width: 800px; height: 450px; }

        .arcade-panel {
            width: 200px; background: linear-gradient(180deg, #111 0%, #222 100%);
            border: 2px solid #333; padding: 15px; display: flex; flex-direction: column;
            justify-content: space-between;
        }

        .sidebar-header { color: var(--neon-pink); font-size: 0.7rem; font-weight: 900; letter-spacing: 2px; border-bottom: 1px solid #333; }

        #levelList { list-style: none; padding: 0; margin: 0; }
        .level-item { padding: 5px 10px; margin-bottom: 3px; background: #000; font-size: 0.75rem; display: flex; justify-content: space-between; color: #444; }
        .level-item.active { color: var(--neon-green); border: 1px solid var(--neon-green); }
        .level-item.cleared { color: var(--neon-blue); }

        .digital-num { color: var(--neon-green); font-family: monospace; font-size: 1.1rem; }

        .stat-box { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.7rem; color: #94a3b8; }

        .dot { width: 8px; height: 8px; border-radius: 50%; background: #333; }
        .dot.active { box-shadow: 0 0 8px currentColor; }
        .dot.green.active { background: #10b981; color: #10b981; }
        .dot.blue.active { background: #3b82f6; color: #3b82f6; }
        .dot.red.active { background: #ef4444; color: #ef4444; }
        .dot.black.active { background: #525252; color: #525252; }
        .dot.purple.active { background: #a855f7; color: #a855f7; }

        .arcade-button {
            background: #d32f2f; color: white; border: none; padding: 10px 20px; font-weight: 900;
            text-transform: uppercase; cursor: pointer; border-bottom: 4px solid #b71c1c;
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }
        .hidden { display: none !important; }

        .retro-label { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.8); padding: 4px 10px; font-size: 0.7rem; z-index: 10; border: 1px solid #333; }

        .pause-icon { position: absolute; top: 15px; right: 45px; background: transparent; border: 1px solid #fff; color: white; cursor: pointer; z-index: 10; }

        .booth-counter { height: 25px; background: var(--wood); border-top: 4px solid #5d4037; border-radius: 0 0 8px 8px; }
    </style>
</head>
<body>

<div class="night-market-scene">
    <header class="neon-header">
        <h1 class="arcade-title">STAND-BY-ME 3D</h1>
    </header>

    <div class="arcade-cabinet">
        <div class="main-layout">
            <div class="canvas-area">
                <div id="status" class="retro-label">3D MODE ACTIVE</div>
                <canvas id="gameCanvas"></canvas>

                <div id="tutorialOverlay" class="overlay arcade-overlay">
                    <h2 class="neon-green">Stand by MaryÔºàÂÆâÁë™ËéâÔºâ</h2>
                    <p>3D Cyberpunk Edition</p>
                    <p>Hook the bottle. Stand it upright.</p>
                    <button id="startBtn" class="arcade-button">START</button>
                </div>

                <div id="pauseOverlay" class="overlay arcade-overlay hidden">
                    <h1 class="neon-yellow">PAUSED</h1>
                    <button id="resumeBtn" class="arcade-button">RESUME</button>
                    <button id="resetBtn" class="arcade-button quit">QUIT</button>
                </div>

                <div id="gameOverOverlay" class="overlay arcade-overlay hidden">
                    <h2 id="deathReason" class="neon-red">GAME OVER</h2>
                    <p class="score-display">SCORE: <span id="finalScore">0</span></p>
                    <button id="restartBtn" class="arcade-button">RETRY</button>
                </div>
                
                <button id="pauseBtn" class="pause-icon">II</button>
            </div>

            <div class="sidebar arcade-panel">
                <div class="panel-section">
                    <div class="sidebar-header">STAGES</div>
                    <ul id="levelList"></ul>
                </div>
                
                <div class="panel-section">
                    <div class="sidebar-header">SKINS</div>
                    <div id="skinObjective" class="objective-item">
                        <div id="skinStatus">Next: Lv 5 Sapphire</div>
                    </div>
                </div>

                <div id="livesContainer">
                    LIVES: <span id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
                </div>

                <div class="panel-section stats-area">
                    <div class="stat-box"><span>SCORE</span><span id="score" class="digital-num">0</span></div>
                    <div class="stat-box"><span>BEST</span><span id="bestScore" class="digital-num">0</span></div>
                    <div class="stat-box"><span>LEVEL</span><span id="level" class="digital-num">1</span></div>
                </div>
            </div>
        </div>
        <div class="booth-counter"></div>
    </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
let audioCtx = null;

// --- 3D ENGINE VARIABLES ---
let scene, camera, renderer, bottleGroup, bottleMesh, ringMesh, tableMesh, ropeLine, pointLight;

// --- GAME STATE (Your Original Logic Preserved) ---
const gameState = {
    paused: true, gameOver: false, hasWon: false,
    level: 1, score: 0, lives: 3,
    bestScore: localStorage.getItem("standByMeBest") || 0,
    bottleAngle: 0, bottleBaseX: 300, originalBaseX: 300, 
    ringX: 400, ringY: 150, ringVX: 0, ringVY: 0,
    mouseX: 400, mouseY: 50,
    isDragging: false, isHooked: false,
    baseVelocity: 0, confetti: [], rain: [],
    timeLeft: 20, maxTime: 20, lastTime: 0,
    shakeTime: 0, shakeIntensity: 0, flashAlpha: 0,
    windForce: 0, windTarget: 0,
    currentPalette: ["#064e3b", "#10b981", "#064e3b"],
    skins: {
        1: ["#064e3b", "#10b981", "#064e3b"], 5: ["#1e3a8a", "#3b82f6", "#1e3a8a"],
        10: ["#7f1d1d", "#ef4444", "#7f1d1d"], 15: ["#171717", "#525252", "#171717"],
        20: ["#4c1d95", "#a855f7", "#4c1d95"]
    }
};

// --- INITIALIZE 3D SCENE ---
function init3D() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0015);

    camera = new THREE.PerspectiveCamera(50, 800 / 450, 0.1, 1000);
    camera.position.set(0, 40, 500);

    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(800, 450);

    // Neon Lights
    const lightL = new THREE.PointLight(0xff007f, 2, 600);
    lightL.position.set(-300, 200, 100);
    scene.add(lightL);

    const lightR = new THREE.PointLight(0x00f2ff, 2, 600);
    lightR.position.set(300, 200, 100);
    scene.add(lightR);

    pointLight = new THREE.PointLight(0xffffff, 0.5, 1000);
    pointLight.position.set(0, 300, 100);
    scene.add(pointLight);

    // Bottle
    bottleGroup = new THREE.Group();
    const bodyGeom = new THREE.CylinderGeometry(22, 22, 140, 32);
    const bodyMat = new THREE.MeshPhongMaterial({ 
        color: gameState.currentPalette[1], 
        shininess: 100,
        emissive: 0x000000
    });
    bottleMesh = new THREE.Mesh(bodyGeom, bodyMat);
    bottleMesh.rotation.z = Math.PI / 2;
    bottleMesh.position.x = 70; // Pivot from base
    bottleGroup.add(bottleMesh);

    // Bottle Cap
    const capGeom = new THREE.CylinderGeometry(8, 8, 20, 16);
    const capMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
    const cap = new THREE.Mesh(capGeom, capMat);
    cap.rotation.z = Math.PI / 2;
    cap.position.x = 150;
    bottleGroup.add(cap);
    
    scene.add(bottleGroup);

    // Table
    const tableGeom = new THREE.BoxGeometry(1000, 10, 300);
    const tableMat = new THREE.MeshStandardMaterial({ 
        color: 0x000000, 
        emissive: 0x00f2ff, 
        emissiveIntensity: 0.5 
    });
    tableMesh = new THREE.Mesh(tableGeom, tableMat);
    tableMesh.position.y = -100;
    scene.add(tableMesh);

    // Ring
    const ringGeom = new THREE.TorusGeometry(22, 3, 16, 100);
    const ringMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    ringMesh = new THREE.Mesh(ringGeom, ringMat);
    scene.add(ringMesh);

    // Rope
    const ropeGeom = new THREE.BufferGeometry();
    const ropeMat = new THREE.LineBasicMaterial({ color: 0x666666 });
    ropeLine = new THREE.Line(ropeGeom, ropeMat);
    scene.add(ropeLine);
}

// --- ORIGINAL AUDIO LOGIC ---
function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playClink(v = 0.1, f = 1200) {
    if (!audioCtx || audioCtx.state !== 'running') return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.setValueAtTime(f, audioCtx.currentTime);
    g.gain.setValueAtTime(v, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.1);
    triggerShake(4); 
}

function playWinSound() {
    if (!audioCtx || audioCtx.state !== 'running') return;
    [523, 659, 783, 1046].forEach((f, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.frequency.setValueAtTime(f, audioCtx.currentTime + i * 0.1);
        g.gain.setValueAtTime(0.05, audioCtx.currentTime + i * 0.1);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(audioCtx.currentTime + i * 0.1); o.stop(audioCtx.currentTime + i * 0.1 + 0.3);
    });
}

// --- CORE PHYSICS LOOP (Your logic untouched) ---
function updatePhysics() {
    if (gameState.paused || gameState.gameOver) return;
    
    const now = performance.now();
    const dt = (now - gameState.lastTime) / 1000;
    gameState.lastTime = now;

    if (!gameState.hasWon) {
        gameState.timeLeft -= dt;
        if (gameState.timeLeft <= 0) loseLife("TIME'S UP!");

        const gravity = 0.05 + (Math.min(gameState.level, 20) * 0.009); 
        const friction = 0.96;

        // Pendulum Logic
        const dx = gameState.mouseX - gameState.ringX;
        const dy = gameState.mouseY - gameState.ringY;
        gameState.ringVX += dx * 0.05 + gameState.windForce * 15;
        gameState.ringVY += dy * 0.05 + 0.5;
        gameState.ringX += gameState.ringVX;
        gameState.ringY += gameState.ringVY;
        gameState.ringVX *= 0.92;
        gameState.ringVY *= 0.92;

        // Bottle Logic
        const capX = gameState.bottleBaseX + Math.cos(gameState.bottleAngle) * 170;
        const capY = 350 + Math.sin(gameState.bottleAngle) * 170;

        if (gameState.isHooked) {
            const dist = Math.hypot(gameState.ringX - capX, gameState.ringY - capY);
            if (dist > 90) {
                gameState.isHooked = false; 
                playClink(0.1, 400);
            } else {
                const targetAngle = Math.atan2(gameState.ringY - 350, gameState.ringX - gameState.bottleBaseX);
                gameState.bottleAngle += (targetAngle - gameState.bottleAngle) * 0.12;
                gameState.baseVelocity += (gameState.ringX - capX) * 0.04;
            }
        } else {
            if (gameState.bottleAngle < 0) gameState.bottleAngle += gravity;
            if (gameState.bottleAngle < -0.65) { loseLife("BOTTLE TIPPED!"); return; } 
            if (gameState.bottleAngle > 0) gameState.bottleAngle = 0;
            gameState.baseVelocity += (gameState.originalBaseX - gameState.bottleBaseX) * 0.035;
        }

        gameState.bottleBaseX += gameState.baseVelocity;
        gameState.baseVelocity *= friction;

        if (gameState.bottleBaseX < 20 || gameState.bottleBaseX > 780) loseLife("BOTTLE SLID OFF!");
        
        // Weather Logic
        if (gameState.level >= 3) {
            if (Math.random() > 0.94) gameState.windTarget = (Math.random() - 0.5) * (0.08 + gameState.level * 0.02);
            gameState.windForce += (gameState.windTarget - gameState.windForce) * 0.08;
        }
    }
}

// --- NEW 3D RENDER LOOP ---
function drawGame() {
    // Sync 3D Bottle
    bottleGroup.position.x = gameState.bottleBaseX - 400;
    bottleGroup.rotation.z = gameState.bottleAngle;
    bottleMesh.material.color.set(gameState.currentPalette[1]);

    // Sync 3D Ring
    ringMesh.position.x = gameState.ringX - 400;
    ringMesh.position.y = -(gameState.ringY - 225);
    ringMesh.material.color.set(gameState.isHooked ? 0x39ff14 : 0xffffff);

    // Update 3D Rope
    const points = [
        new THREE.Vector3(0, 225, 0),
        new THREE.Vector3(gameState.windForce * 500, 100, 0),
        ringMesh.position.clone()
    ];
    const curve = new THREE.QuadraticBezierCurve3(points[0], points[1], points[2]);
    ropeLine.geometry.dispose();
    ropeLine.geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(20));

    // Shake
    if (gameState.shakeTime > 0) {
        camera.position.x = (Math.random() - 0.5) * gameState.shakeIntensity;
        gameState.shakeTime--;
    } else {
        camera.position.x = 0;
    }

    renderer.render(scene, camera);
}

// --- GAME STATE HELPERS ---
function init(keepLives = false) {
    if (!keepLives) { gameState.lives = 3; gameState.score = 0; gameState.level = 1; }
    gameState.bottleBaseX = gameState.originalBaseX;
    gameState.bottleAngle = 0;
    gameState.gameOver = false; gameState.timeLeft = 20;
    gameState.baseVelocity = 0; gameState.hasWon = false;
    updateUI(); updateLevelSidebar(); checkObjectives(); resetRing();
}

function updateUI() {
    document.getElementById("score").textContent = gameState.score;
    document.getElementById("level").textContent = gameState.level;
    document.getElementById("bestScore").textContent = gameState.bestScore;
    document.getElementById("livesDisplay").textContent = "‚ù§Ô∏è".repeat(gameState.lives);
}

function loseLife(reason) {
    gameState.lives--;
    playClink(0.5, 100);
    if (gameState.lives <= 0) triggerGameOver(reason);
    else init(true);
}

function checkWin() {
    if (gameState.hasWon || gameState.gameOver || gameState.paused) return;
    if (gameState.bottleAngle <= -1.47 && Math.abs(gameState.baseVelocity) < 0.15) {
        gameState.hasWon = true; gameState.score += 100; playWinSound();
        updateUI();
        setTimeout(() => { gameState.level++; init(true); gameState.lastTime = performance.now(); }, 2000);
    }
}

function updateLevelSidebar() {
    const list = document.getElementById("levelList");
    list.innerHTML = "";
    for (let i = 1; i <= Math.max(5, gameState.level + 2); i++) {
        const li = document.createElement("li");
        li.className = "level-item" + (i < gameState.level ? " cleared" : (i === gameState.level ? " active" : ""));
        li.innerHTML = `<span>LV ${i}</span> <span>${i < gameState.level ? '‚úì' : (i === gameState.level ? 'LIVE' : 'üîí')}</span>`;
        list.appendChild(li);
    }
}

function checkObjectives() {
    let unlockedLv = 1;
    if (gameState.level >= 20) unlockedLv = 20;
    else if (gameState.level >= 15) unlockedLv = 15;
    else if (gameState.level >= 10) unlockedLv = 10;
    else if (gameState.level >= 5) unlockedLv = 5;
    gameState.currentPalette = gameState.skins[unlockedLv];
}

function triggerShake(intensity) { gameState.shakeTime = 10; gameState.shakeIntensity = intensity; }
function resetRing() { gameState.isHooked = false; gameState.isDragging = false; gameState.ringX = 400; gameState.ringY = 150; gameState.ringVX = 0; gameState.ringVY = 0; }

// --- CONTROLS ---
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (800 / rect.width);
    const y = (e.clientY - rect.top) * (450 / rect.height);
    if (Math.hypot(x - gameState.ringX, y - gameState.ringY) < 60) gameState.isDragging = true;
});

window.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    gameState.mouseX = (e.clientX - rect.left) * (800 / rect.width);
    gameState.mouseY = (e.clientY - rect.top) * (450 / rect.height);
    if (gameState.isDragging && !gameState.paused && !gameState.isHooked) {
        const capX = gameState.bottleBaseX + Math.cos(gameState.bottleAngle) * 170;
        const capY = 350 + Math.sin(gameState.bottleAngle) * 170;
        if (Math.hypot(gameState.ringX - capX, gameState.ringY - capY) < 30) {
            gameState.isHooked = true; playClink(0.2);
        }
    }
});
window.addEventListener('mouseup', () => gameState.isDragging = false);

// --- UI BUTTONS ---
document.getElementById("pauseBtn").onclick = () => { gameState.paused = true; document.getElementById("pauseOverlay").classList.remove("hidden"); };
document.getElementById("resumeBtn").onclick = () => { initAudio(); gameState.paused = false; gameState.lastTime = performance.now(); document.getElementById("pauseOverlay").classList.add("hidden"); };
document.getElementById("startBtn").onclick = () => { initAudio(); gameState.paused = false; document.getElementById("tutorialOverlay").classList.add("hidden"); init(); gameState.lastTime = performance.now(); };
document.getElementById("restartBtn").onclick = () => { initAudio(); gameState.paused = false; document.getElementById("gameOverOverlay").classList.add("hidden"); init(); gameState.lastTime = performance.now(); };
function triggerGameOver(reason) { gameState.gameOver = true; document.getElementById("deathReason").textContent = reason; document.getElementById("gameOverOverlay").classList.remove("hidden"); }

window.onload = () => { 
    init3D();
    init(); 
    const loop = () => { updatePhysics(); checkWin(); drawGame(); requestAnimationFrame(loop); }; 
    loop(); 
};
</script>
</body>
</html>
