<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STAND-BY-ME 3D | Neon Market</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --neon-green: #39ff14; --neon-pink: #ff007f; --neon-blue: #00f2ff; }
        body { background: #050505; color: white; margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        .arcade-cabinet { background: #111; padding: 10px; border: 4px solid #222; border-radius: 12px; box-shadow: 0 0 100px #000; }
        .main-layout { display: flex; gap: 15px; background: #000; padding: 5px; }
        .canvas-area { position: relative; width: 800px; height: 450px; border: 1px solid #333; }
        #gameCanvas { display: block; }
        .sidebar { width: 180px; padding: 15px; border-left: 1px solid #222; display: flex; flex-direction: column; justify-content: space-between; }
        .stat-label { font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 1px; }
        .digital { color: var(--neon-green); font-family: monospace; font-size: 1.4rem; margin-bottom: 10px; }
        .timer-container { width: 100%; height: 6px; background: #222; margin: 10px 0; }
        #timerFill { width: 100%; height: 100%; background: var(--neon-pink); box-shadow: 0 0 10px var(--neon-pink); }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        .hidden { display: none !important; }
        .arcade-button { background: transparent; color: white; border: 2px solid var(--neon-blue); padding: 12px 30px; font-weight: bold; cursor: pointer; text-shadow: 0 0 5px var(--neon-blue); box-shadow: 0 0 10px var(--neon-blue); }
        .arcade-button:hover { background: var(--neon-blue); color: black; }
    </style>
</head>
<body>

<div class="arcade-cabinet">
    <div class="main-layout">
        <div class="canvas-area">
            <canvas id="gameCanvas"></canvas>
            
            <div id="tutorialOverlay" class="overlay">
                <h1 style="color:var(--neon-pink); letter-spacing: 5px;">NIGHT MARKET</h1>
                <p style="color:#888;">Stand the bottle upright to win.</p>
                <button id="startBtn" class="arcade-button">START SESSION</button>
            </div>

            <div id="gameOverOverlay" class="overlay hidden">
                <h2 id="deathReason" style="color:var(--neon-pink)">GAME OVER</h2>
                <button id="restartBtn" class="arcade-button">RETRY</button>
            </div>
        </div>

        <div class="sidebar">
            <div>
                <span class="stat-label">Time</span>
                <div class="timer-container"><div id="timerFill"></div></div>
                <span class="stat-label">Score</span>
                <div id="score" class="digital">0</div>
                <span class="stat-label">Stage</span>
                <div id="level" class="digital" style="color:var(--neon-blue)">1</div>
            </div>
            <div>
                <span class="stat-label">Lives</span>
                <div id="livesDisplay" style="font-size: 1.2rem; margin-top:5px;">❤️❤️❤️</div>
            </div>
        </div>
    </div>
</div>

<script>
// --- CORE CONFIG ---
const canvas = document.getElementById("gameCanvas");
let scene, camera, renderer, bottleGroup, ringMesh, ropeLine;
let lanterns = [], clouds = [];

const gameState = {
    paused: true, gameOver: false, hasWon: false,
    level: 1, score: 0, lives: 3,
    bottleAngle: 0, bottleBaseX: 400,
    ringX: 400, ringY: 150, ringVX: 0, ringVY: 0,
    mouseX: 400, mouseY: 50,
    isDragging: false, isHooked: false,
    baseVelocity: 0, timeLeft: 20, maxTime: 20,
    windForce: 0, windTarget: 0,
    currentPalette: ["#064e3b", "#10b981"]
};

function init3D() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020205);
    scene.fog = new THREE.Fog(0x020205, 100, 900);

    camera = new THREE.PerspectiveCamera(45, 800 / 450, 1, 2000);
    camera.position.set(0, 80, 500); // Eye-level perspective

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(800, 450);

    // 1. LIGHTING (Neon Glow)
    const hemi = new THREE.HemisphereLight(0x444444, 0x000000, 0.6);
    scene.add(hemi);

    // 2. WET ASPHALT GROUND
    const floorGeo = new THREE.PlaneGeometry(3000, 3000);
    const floorMat = new THREE.MeshStandardMaterial({ 
        color: 0x080808, roughness: 0.05, metalness: 0.8 
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -150;
    scene.add(floor);

    // 3. STALL STRUCTURE (Back and Sides)
    const createWall = (w, h, x, z, color) => {
        const geo = new THREE.BoxGeometry(w, h, 10);
        const mat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, h/2 - 150, z);
        scene.add(mesh);

        // Neon Sign on wall
        const signGeo = new THREE.PlaneGeometry(w*0.8, 10);
        const signMat = new THREE.MeshBasicMaterial({ color: color });
        const sign = new THREE.Mesh(signGeo, signMat);
        sign.position.set(x, h - 140, z + 6);
        scene.add(sign);
    };
    createWall(400, 300, -500, -200, 0xff007f); // Left Stall
    createWall(400, 300, 500, -200, 0x00f2ff);  // Right Stall

    // 4. THE GAME TABLE
    const tableGeo = new THREE.BoxGeometry(600, 20, 250);
    const tableMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1 });
    const table = new THREE.Mesh(tableGeo, tableMat);
    table.position.y = -90;
    scene.add(table);

    // 5. THE BOTTLE
    bottleGroup = new THREE.Group();
    const bodyGeo = new THREE.CylinderGeometry(20, 24, 130, 32);
    const bodyMat = new THREE.MeshPhysicalMaterial({ 
        color: 0x10b981, transmission: 0.5, thickness: 2, roughness: 0
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.rotation.z = Math.PI / 2;
    body.position.x = 65; // Offset so it pivots on base
    bottleGroup.add(body);
    
    const cap = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 20), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
    cap.rotation.z = Math.PI / 2; cap.position.x = 145;
    bottleGroup.add(cap);
    scene.add(bottleGroup);

    // 6. THE RING
    ringMesh = new THREE.Mesh(
        new THREE.TorusGeometry(22, 3, 16, 100),
        new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff })
    );
    scene.add(ringMesh);

    // 7. ROPE
    ropeLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x666666 }));
    scene.add(ropeLine);

    // 8. LANTERNS
    for(let i=0; i<6; i++) {
        const lantern = new THREE.Mesh(new THREE.CylinderGeometry(15, 15, 40), new THREE.MeshBasicMaterial({ color: 0xff3300 }));
        lantern.position.set(-450 + (i*180), 220, -100);
        scene.add(lantern);
        lanterns.push(lantern);
        const pLight = new THREE.PointLight(0xff3300, 1, 300);
        pLight.position.copy(lantern.position);
        scene.add(pLight);
    }
}

function updatePhysics() {
    if (gameState.paused || gameState.gameOver) return;
    const now = performance.now();
    const dt = (now - (gameState.lastTime || now)) / 1000;
    gameState.lastTime = now;

    gameState.timeLeft -= dt;
    document.getElementById("timerFill").style.width = (gameState.timeLeft / gameState.maxTime * 100) + "%";
    if (gameState.timeLeft <= 0) loseLife("TIME EXPIRED");

    // RING SWING
    gameState.ringVX += (gameState.mouseX - gameState.ringX) * 0.05 + (gameState.windForce * 20);
    gameState.ringVY += (gameState.mouseY - gameState.ringY) * 0.05 + 0.8;
    gameState.ringX += gameState.ringVX;
    gameState.ringY += gameState.ringVY;
    gameState.ringVX *= 0.92; gameState.ringVY *= 0.92;

    const capX = gameState.bottleBaseX + Math.cos(gameState.bottleAngle) * 170;
    const capY = 350 + Math.sin(gameState.bottleAngle) * 170;

    if (gameState.isHooked) {
        if (Math.hypot(gameState.ringX - capX, gameState.ringY - capY) > 95) {
            gameState.isHooked = false;
        } else {
            // FIXED ROTATION (Tilts towards ring)
            const targetAngle = Math.atan2(gameState.ringY - 350, gameState.ringX - gameState.bottleBaseX);
            gameState.bottleAngle += (targetAngle - gameState.bottleAngle) * 0.15;
            gameState.baseVelocity += (gameState.ringX - capX) * 0.05;
        }
    } else {
        const grav = 0.06 + (gameState.level * 0.005);
        if (gameState.bottleAngle < 0) gameState.bottleAngle += grav;
        if (gameState.bottleAngle < -0.7) { loseLife("BOTTLE FELL"); return; }
        if (gameState.bottleAngle > 0) gameState.bottleAngle = 0;
        gameState.baseVelocity += (400 - gameState.bottleBaseX) * 0.04;
    }

    gameState.bottleBaseX += gameState.baseVelocity;
    gameState.baseVelocity *= 0.95;

    if (gameState.bottleBaseX < 110 || gameState.bottleBaseX > 690) loseLife("SLID OFF");
}

function drawGame() {
    // Correcting bottle position relative to table surface
    bottleGroup.position.x = gameState.bottleBaseX - 400;
    bottleGroup.position.y = -80; 
    
    // Correcting Rotation Mapping
    bottleGroup.rotation.z = gameState.bottleAngle;
    
    // Ring and Rope
    ringMesh.position.x = gameState.ringX - 400;
    ringMesh.position.y = -(gameState.ringY - 225);
    ringMesh.material.emissiveIntensity = gameState.isHooked ? 3 : 0.5;

    const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(0, 225, 0),
        new THREE.Vector3(gameState.windForce * 500, 100, 0),
        ringMesh.position.clone()
    );
    ropeLine.geometry.dispose();
    ropeLine.geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(20));

    // Subtle Lantern Anims
    lanterns.forEach((l, i) => l.position.y = 220 + Math.sin(Date.now()*0.001 + i)*5);

    renderer.render(scene, camera);
}

function loseLife(reason) {
    gameState.lives--;
    document.getElementById("livesDisplay").textContent = "❤️".repeat(gameState.lives);
    if (gameState.lives <= 0) {
        document.getElementById("gameOverOverlay").classList.remove("hidden");
        document.getElementById("deathReason").textContent = reason;
    } else {
        resetPositions();
    }
}

function resetPositions() {
    gameState.bottleBaseX = 400; gameState.bottleAngle = 0;
    gameState.ringX = 400; gameState.ringY = 150;
    gameState.isHooked = false; gameState.timeLeft = 20;
    gameState.ringVX = 0; gameState.ringVY = 0;
}

function checkWin() {
    if (gameState.hasWon || gameState.gameOver || gameState.paused) return;
    if (gameState.bottleAngle <= -1.48 && Math.abs(gameState.baseVelocity) < 0.2) {
        gameState.hasWon = true; gameState.score += 100;
        document.getElementById("score").textContent = gameState.score;
        setTimeout(() => { 
            gameState.level++; 
            document.getElementById("level").textContent = gameState.level;
            gameState.hasWon = false; 
            resetPositions(); 
        }, 1500);
    }
}

// INPUTS
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (800 / rect.width);
    const y = (e.clientY - rect.top) * (450 / rect.height);
    if (Math.hypot(x - gameState.ringX, y - gameState.ringY) < 60) gameState.isDragging = true;
});
window.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    gameState.mouseX = (e.clientX - rect.left) * (800 / rect.width);
    gameState.mouseY = (e.clientY - rect.top) * (450 / rect.height);
    if (gameState.isDragging && !gameState.isHooked) {
        const capX = gameState.bottleBaseX + Math.cos(gameState.bottleAngle) * 170;
        const capY = 350 + Math.sin(gameState.bottleAngle) * 170;
        if (Math.hypot(gameState.ringX - capX, gameState.ringY - capY) < 30) gameState.isHooked = true;
    }
});
window.addEventListener('mouseup', () => gameState.isDragging = false);

document.getElementById("startBtn").onclick = () => { gameState.paused = false; document.getElementById("tutorialOverlay").classList.add("hidden"); };
document.getElementById("restartBtn").onclick = () => { location.reload(); };

window.onload = () => { init3D(); const loop = () => { updatePhysics(); checkWin(); drawGame(); requestAnimationFrame(loop); }; loop(); };
</script>
</body>
</html>
