<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STAND-BY-ME 3D | Night Market Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        :root { 
            --neon-green: #39ff14; 
            --neon-pink: #ff007f; 
            --neon-blue: #00f2ff; 
            --wood: #3e2723; 
            --bg-dark: #0a0a0c;
        }

        body { 
            background: var(--bg-dark); 
            color: white; 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            overflow: hidden; 
        }

        .night-market-scene { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 15px; 
        }

        .arcade-title { 
            margin: 0; 
            font-size: 2.8rem; 
            font-weight: 900; 
            letter-spacing: 6px; 
            color: #fff; 
            text-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink); 
            text-transform: uppercase;
        }

        .arcade-cabinet { 
            background: #1a1a1a; 
            padding: 12px; 
            border: 4px solid #333; 
            border-radius: 12px; 
            box-shadow: 0 0 60px rgba(0,0,0,0.9); 
        }

        .main-layout { 
            display: flex; 
            gap: 15px; 
            background: #000; 
            padding: 8px; 
            border-radius: 4px;
        }

        .canvas-area { 
            position: relative; 
            width: 800px; 
            height: 450px; 
            border: 2px solid #222; 
            overflow: hidden; 
            background: #000;
        }

        #gameCanvas { 
            display: block; 
            cursor: crosshair;
        }

        .arcade-panel { 
            width: 200px; 
            background: linear-gradient(180deg, #111 0%, #1a1a1a 100%); 
            border: 1px solid #333; 
            padding: 15px; 
            display: flex; 
            flex-direction: column; 
            justify-content: space-between; 
        }

        .sidebar-header { 
            color: var(--neon-pink); 
            font-size: 0.75rem; 
            font-weight: 900; 
            letter-spacing: 1px;
            border-bottom: 1px solid #333; 
            margin-bottom: 10px; 
            padding-bottom: 5px;
        }

        #levelList { 
            list-style: none; 
            padding: 0; 
            margin: 0;
            max-height: 180px;
            overflow-y: hidden;
        }

        .level-item { 
            padding: 6px; 
            margin-bottom: 4px;
            display: flex; 
            justify-content: space-between; 
            font-size: 0.7rem; 
            color: #555; 
            background: rgba(0,0,0,0.3);
        }

        .level-item.active { 
            color: var(--neon-green); 
            border: 1px solid var(--neon-green); 
            background: rgba(57, 255, 20, 0.1);
        }

        .level-item.cleared { 
            color: var(--neon-blue); 
        }

        .stat-box { 
            display: flex; 
            justify-content: space-between; 
            font-size: 0.85rem; 
            margin-bottom: 8px;
            color: #aaa;
        }

        .digital-num { 
            color: var(--neon-green); 
            font-family: 'Courier New', Courier, monospace; 
            font-weight: bold;
        }

        .arcade-button { 
            background: #e91e63; 
            color: white; 
            border: none; 
            padding: 12px 24px; 
            font-weight: 900; 
            text-transform: uppercase;
            cursor: pointer; 
            box-shadow: 0 4px 0 #ad1457;
            transition: transform 0.1s;
        }

        .arcade-button:active { 
            transform: translateY(3px); 
            box-shadow: 0 1px 0 #ad1457;
        }

        .overlay { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 100; 
            text-align: center;
        }

        .hidden { display: none !important; }

        .pause-icon { 
            position: absolute; 
            top: 15px; 
            right: 15px; 
            background: rgba(0,0,0,0.5); 
            border: 1px solid #fff; 
            color: #fff; 
            padding: 5px 10px;
            cursor: pointer; 
            z-index: 10; 
        }

        #livesDisplay {
            font-size: 1.2rem;
            letter-spacing: 5px;
            text-align: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>

<div class="night-market-scene">
    <h1 class="arcade-title">Stand By Me 3D</h1>
    
    <div class="arcade-cabinet">
        <div class="main-layout">
            <div class="canvas-area">
                <canvas id="gameCanvas"></canvas>
                
                <div id="tutorialOverlay" class="overlay">
                    <h2 style="color:var(--neon-green); margin-bottom: 0;">STALL #07</h2>
                    <h3 style="margin-top: 5px;">BOTTLE MASTER</h3>
                    <p style="max-width: 400px; line-height: 1.6; color: #ccc;">
                        Drag the ring to hook the bottle neck.<br>
                        Slowly lift the bottle until it stands upright.<br>
                        Don't let the bottle slide off the table!
                    </p>
                    <button id="startBtn" class="arcade-button">Start Game</button>
                </div>

                <div id="pauseOverlay" class="overlay hidden">
                    <h1 style="color:var(--neon-blue)">PAUSED</h1>
                    <button id="resumeBtn" class="arcade-button">Resume</button>
                </div>

                <div id="gameOverOverlay" class="overlay hidden">
                    <h2 id="deathReason" style="color:var(--neon-pink); font-size: 2.5rem;">GAME OVER</h2>
                    <p style="font-size: 1.2rem;">FINAL SCORE: <span id="finalScore" class="digital-num">0</span></p>
                    <button id="restartBtn" class="arcade-button">Play Again</button>
                </div>
                
                <button id="pauseBtn" class="pause-icon">PAUSE</button>
            </div>

            <div class="sidebar arcade-panel">
                <div>
                    <div class="sidebar-header">STALL LEVELS</div>
                    <ul id="levelList"></ul>
                </div>
                
                <div>
                    <div class="stat-box"><span>SCORE</span><span id="score" class="digital-num">0</span></div>
                    <div class="stat-box"><span>BEST</span><span id="bestScore" class="digital-num">0</span></div>
                    <div class="stat-box"><span>LEVEL</span><span id="level" class="digital-num">1</span></div>
                    <div class="sidebar-header" style="margin-top: 15px;">STAMINA</div>
                    <div id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// --- GAME STATE & LOGIC ---
const canvas = document.getElementById("gameCanvas");
let scene, camera, renderer, bottleGroup, ringMesh, ropeLine, pointLight;
let audioCtx = null;

const gameState = {
    paused: true,
    gameOver: false,
    hasWon: false,
    level: 1,
    score: 0,
    lives: 3,
    bestScore: localStorage.getItem("standByMeBest") || 0,
    // Physics Logic Variables
    bottleAngle: 0,
    bottleBaseX: 400,
    originalBaseX: 400,
    ringX: 400,
    ringY: 150,
    ringVX: 0,
    ringVY: 0,
    mouseX: 400,
    mouseY: 50,
    isDragging: false,
    isHooked: false,
    baseVelocity: 0,
    timeLeft: 20,
    shakeTime: 0,
    shakeIntensity: 0,
    windForce: 0,
    windTarget: 0,
    currentPalette: ["#064e3b", "#10b981", "#064e3b"]
};

// --- INITIALIZE 3D ENVIRONMENT ---
function init3D() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a0c, 0.002);

    camera = new THREE.PerspectiveCamera(45, 800 / 450, 1, 1000);
    camera.position.set(0, 70, 500);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(800, 450);
    renderer.setPixelRatio(window.devicePixelRatio);

    // Neon Market Lighting
    const pinkLight = new THREE.PointLight(0xff007f, 2.5, 500);
    pinkLight.position.set(-250, 150, 50);
    scene.add(pinkLight);

    const blueLight = new THREE.PointLight(0x00f2ff, 2.5, 500);
    blueLight.position.set(250, 150, 50);
    scene.add(blueLight);

    pointLight = new THREE.PointLight(0xffffff, 0.4, 1000);
    scene.add(pointLight);

    // Rainy Ground (Reflection)
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(2000, 2000),
        new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1, metalness: 0.8 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -140;
    scene.add(floor);

    // Wooden Game Table
    const table = new THREE.Mesh(
        new THREE.BoxGeometry(650, 15, 220),
        new THREE.MeshStandardMaterial({ color: 0x1a0f0a, roughness: 0.9 })
    );
    table.position.y = -105;
    scene.add(table);

    // Table Neon Trim
    const trim = new THREE.Mesh(
        new THREE.BoxGeometry(660, 2, 230),
        new THREE.MeshBasicMaterial({ color: 0x00f2ff })
    );
    trim.position.y = -98;
    scene.add(trim);

    // 3D Bottle Assembly
    bottleGroup = new THREE.Group();
    const bottleBody = new THREE.Mesh(
        new THREE.CylinderGeometry(22, 24, 135, 32),
        new THREE.MeshPhysicalMaterial({ 
            color: 0x10b981, 
            transmission: 0.4, 
            transparent: true, 
            thickness: 3, 
            roughness: 0.1 
        })
    );
    bottleBody.rotation.z = Math.PI / 2;
    bottleBody.position.x = 67; // Pivot adjustment
    bottleGroup.add(bottleBody);

    const bottleCap = new THREE.Mesh(
        new THREE.CylinderGeometry(10, 10, 25, 16),
        new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x330000 })
    );
    bottleCap.rotation.z = Math.PI / 2;
    bottleCap.position.x = 155;
    bottleGroup.add(bottleCap);
    scene.add(bottleGroup);

    // Ring & Rope
    ringMesh = new THREE.Mesh(
        new THREE.TorusGeometry(22, 2.5, 16, 64),
        new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5 })
    );
    scene.add(ringMesh);

    ropeLine = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0xaaaaaa })
    );
    scene.add(ropeLine);

    // Background Stall Silhouettes
    for(let i = 0; i < 5; i++) {
        const stall = new THREE.Mesh(
            new THREE.BoxGeometry(120, 180, 40),
            new THREE.MeshStandardMaterial({ color: 0x000000, emissive: (i % 2 === 0 ? 0xff007f : 0x00f2ff), emissiveIntensity: 0.15 })
        );
        stall.position.set(-500 + (i * 250), 20, -350);
        scene.add(stall);
    }
}

// --- CORE PHYSICS (Preserving Your Logic) ---
function updatePhysics() {
    if (gameState.paused || gameState.gameOver) return;
    
    const now = performance.now();
    const dt = (now - (gameState.lastTime || now)) / 1000;
    gameState.lastTime = now;

    if (!gameState.hasWon) {
        gameState.timeLeft -= dt;
        if (gameState.timeLeft <= 0) loseLife("TIME EXPIRED!");

        // Original Swing Math
        gameState.ringVX += (gameState.mouseX - gameState.ringX) * 0.05 + (gameState.windForce * 22);
        gameState.ringVY += (gameState.mouseY - gameState.ringY) * 0.05 + 0.8;
        gameState.ringX += gameState.ringVX;
        gameState.ringY += gameState.ringVY;
        gameState.ringVX *= 0.92;
        gameState.ringVY *= 0.92;

        const capX = gameState.bottleBaseX + Math.cos(gameState.bottleAngle) * 170;
        const capY = 350 + Math.sin(gameState.bottleAngle) * 170;

        if (gameState.isHooked) {
            if (Math.hypot(gameState.ringX - capX, gameState.ringY - capY) > 95) {
                gameState.isHooked = false;
                playClink(0.1, 400);
            } else {
                const targetAngle = Math.atan2(gameState.ringY - 350, gameState.ringX - gameState.bottleBaseX);
                gameState.bottleAngle += (targetAngle - gameState.bottleAngle) * 0.14;
                gameState.baseVelocity += (gameState.ringX - capX) * 0.045;
            }
        } else {
            const grav = 0.06 + (gameState.level * 0.006);
            if (gameState.bottleAngle < 0) gameState.bottleAngle += grav;
            if (gameState.bottleAngle < -0.72) { loseLife("BOTTLE TOPPLED!"); return; }
            if (gameState.bottleAngle > 0) gameState.bottleAngle = 0;
            gameState.baseVelocity += (400 - gameState.bottleBaseX) * 0.04;
        }

        gameState.bottleBaseX += gameState.baseVelocity;
        gameState.baseVelocity *= 0.95;

        // Boundary Check
        if (gameState.bottleBaseX < 90 || gameState.bottleBaseX > 710) loseLife("SLID OFF TABLE!");

        // Wind Force Logic
        if (gameState.level >= 2) {
            if (Math.random() > 0.96) gameState.windTarget = (Math.random() - 0.5) * (0.12 + gameState.level * 0.02);
            gameState.windForce += (gameState.windTarget - gameState.windForce) * 0.04;
        }
    }
}

function drawGame() {
    // Sync 3D Bottle
    bottleGroup.position.x = gameState.bottleBaseX - 400;
    bottleGroup.position.y = -100;
    bottleGroup.rotation.z = gameState.bottleAngle;
    
    // Sync 3D Ring
    ringMesh.position.x = gameState.ringX - 400;
    ringMesh.position.y = -(gameState.ringY - 225);
    ringMesh.material.emissiveIntensity = gameState.isHooked ? 2 : 0.4;
    ringMesh.material.color.set(gameState.isHooked ? 0x39ff14 : 0xffffff);

    // Dynamic 3D Rope
    const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(0, 225, 0), // Ceiling anchor
        new THREE.Vector3(gameState.windForce * 700, 100, 0), // Wind arc
        ringMesh.position.clone()
    );
    ropeLine.geometry.dispose();
    ropeLine.geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(20));

    // Juice Box Shake Effect
    if (gameState.shakeTime > 0) {
        camera.position.x = (Math.random() - 0.5) * gameState.shakeIntensity;
        gameState.shakeTime--;
    } else { camera.position.x = 0; }

    renderer.render(scene, camera);
}

// --- AUDIO & UI SYSTEM ---
function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playClink(v, f) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.setValueAtTime(f, audioCtx.currentTime);
    g.gain.setValueAtTime(v, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.1);
    gameState.shakeTime = 8; gameState.shakeIntensity = 4;
}

function loseLife(reason) {
    gameState.lives--;
    updateUI();
    if (gameState.lives <= 0) {
        gameState.gameOver = true;
        document.getElementById("deathReason").textContent = reason;
        document.getElementById("finalScore").textContent = gameState.score;
        document.getElementById("gameOverOverlay").classList.remove("hidden");
    } else {
        resetPositions();
    }
}

function resetPositions() {
    gameState.bottleBaseX = 400;
    gameState.bottleAngle = 0;
    gameState.ringX = 400;
    gameState.ringY = 150;
    gameState.isHooked = false;
    gameState.timeLeft = 20;
    gameState.baseVelocity = 0;
    gameState.ringVX = 0;
    gameState.ringVY = 0;
}

function checkWin() {
    if (gameState.hasWon || gameState.gameOver || gameState.paused) return;
    // Tipping threshold logic
    if (gameState.bottleAngle <= -1.48 && Math.abs(gameState.baseVelocity) < 0.22) {
        gameState.hasWon = true;
        gameState.score += 100;
        if (gameState.score > gameState.bestScore) {
            gameState.bestScore = gameState.score;
            localStorage.setItem("standByMeBest", gameState.bestScore);
        }
        updateUI();
        setTimeout(() => {
            gameState.level++;
            gameState.hasWon = false;
            resetPositions();
            updateLevelSidebar();
        }, 1600);
    }
}

function updateUI() {
    document.getElementById("score").textContent = gameState.score;
    document.getElementById("bestScore").textContent = gameState.bestScore;
    document.getElementById("level").textContent = gameState.level;
    document.getElementById("livesDisplay").textContent = "‚ù§Ô∏è".repeat(gameState.lives);
}

function updateLevelSidebar() {
    const list = document.getElementById("levelList");
    list.innerHTML = "";
    for (let i = 1; i <= Math.max(gameState.level + 2, 5); i++) {
        const li = document.createElement("li");
        li.className = "level-item" + (i < gameState.level ? " cleared" : (i === gameState.level ? " active" : ""));
        li.innerHTML = `<span>STALL #${i.toString().padStart(2,'0')}</span> <span>${i < gameState.level ? '‚úì' : (i === gameState.level ? 'PLAY' : 'üîí')}</span>`;
        list.appendChild(li);
    }
}

// --- CONTROLS ---
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (800 / rect.width);
    const y = (e.clientY - rect.top) * (450 / rect.height);
    if (Math.hypot(x - gameState.ringX, y - gameState.ringY) < 60) gameState.isDragging = true;
});

window.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    gameState.mouseX = (e.clientX - rect.left) * (800 / rect.width);
    gameState.mouseY = (e.clientY - rect.top) * (450 / rect.height);
    
    if (gameState.isDragging && !gameState.isHooked && !gameState.paused) {
        const capX = gameState.bottleBaseX + Math.cos(gameState.bottleAngle) * 170;
        const capY = 350 + Math.sin(gameState.bottleAngle) * 170;
        if (Math.hypot(gameState.ringX - capX, gameState.ringY - capY) < 32) {
            gameState.isHooked = true;
            initAudio();
            playClink(0.2, 850);
        }
    }
});

window.addEventListener('mouseup', () => gameState.isDragging = false);

// --- UI BUTTON CLICKS ---
document.getElementById("startBtn").onclick = () => {
    initAudio();
    gameState.paused = false;
    document.getElementById("tutorialOverlay").classList.add("hidden");
    updateLevelSidebar();
};

document.getElementById("pauseBtn").onclick = () => {
    gameState.paused = true;
    document.getElementById("pauseOverlay").classList.remove("hidden");
};

document.getElementById("resumeBtn").onclick = () => {
    gameState.paused = false;
    document.getElementById("pauseOverlay").classList.add("hidden");
};

document.getElementById("restartBtn").onclick = () => {
    location.reload();
};

// --- START ENGINE ---
window.onload = () => {
    init3D();
    updateUI();
    updateLevelSidebar();
    
    function gameLoop() {
        updatePhysics();
        checkWin();
        drawGame();
        requestAnimationFrame(gameLoop);
    }
    gameLoop();
};
</script>
</body>
</html>
